using System;
using System.Collections.Generic;
using System.Diagnostics;
using Dargon.Commons;
using Dargon.Commons.Cli;
using Dargon.Commons.Collections;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Dargon.Luna.Transpiler.Deoop {
   public class ShaderTranspiler {
      private readonly SemanticModelCache semanticModelCache;

      public ShaderTranspiler(SemanticModelCache semanticModelCache) {
         this.semanticModelCache = semanticModelCache;
      }

      public void Transpile(MethodDeclarationSyntax method) {
         var context = new TranspilationContext();
         context.SemanticModelCache = semanticModelCache;
         context.QueuedMethods.Add(new MethodTranspilationJob {
            Method = method,
         });

         var visitor = new TranspilationVisitor(context);
         for (var i = 0; i < context.QueuedMethods.Count; i++) {
            var target = context.QueuedMethods[i];
            visitor.Transpile(target);
         }
      }

      public class TranspilationContext {
         public SemanticModelCache SemanticModelCache;

         public AddOnlyOrderedHashSet<MethodTranspilationJob> QueuedMethods { get; } = new AddOnlyOrderedHashSet<MethodTranspilationJob>();
         public AddOnlyOrderedHashSet<TypeDeclarationSyntax> QueuedTypes { get; } = new AddOnlyOrderedHashSet<TypeDeclarationSyntax>();
      }

      public struct MethodTranspilationJob : IEquatable<MethodTranspilationJob> {
         public MethodDeclarationSyntax Method;

         #region autogenerated equality
         public bool Equals(MethodTranspilationJob other) {
            return Equals(Method, other.Method);
         }

         public override bool Equals(object obj) {
            return obj is MethodTranspilationJob other && Equals(other);
         }

         public override int GetHashCode() {
            return (Method != null ? Method.GetHashCode() : 0);
         }

         public static bool operator ==(MethodTranspilationJob left, MethodTranspilationJob right) {
            return left.Equals(right);
         }

         public static bool operator !=(MethodTranspilationJob left, MethodTranspilationJob right) {
            return !left.Equals(right);
         }
         #endregion
      }

      public class TranspilationVisitor : CSharpSyntaxVisitor {
         private readonly TranspilationContext context;

         public TranspilationVisitor(TranspilationContext context) {
            this.context = context;
         }

         private TranspilationMode mode;

         public void Transpile(MethodTranspilationJob job) {
            mode = TranspilationMode.Method;
            Visit(job.Method);
         }

         [Flags]
         public enum TokenFlags {
            Trivia = 1 << 0,
            Whitespace = 1 << 1,
         }

         public void Emit(string token, SyntaxNode tag, TokenFlags flags = 0) {
            var (fg, bg) = (flags & TokenFlags.Trivia) != 0 ? (ConsoleColor.DarkGray, null) :
               (flags & TokenFlags.Whitespace) != 0 ? (ConsoleColor.Gray, null) :
               ((ConsoleColor?)ConsoleColor.White, (ConsoleColor?)null);

            using (new ConsoleColorSwitch().To(fg, bg)) {
               Console.Write(token + " ");
            }
         }

         public void EmitSpace(SyntaxNode tag) {
            Emit("", tag, TokenFlags.Whitespace);
         }

         private Exception Abort(string reason, SyntaxNode node) {
            Console.WriteLine("=== " + reason + " ===");
            throw Diag.DumpExpressionAndSyntaxTreeThenReturnThrow(node);
         }

         private Exception AbortNotSupported(string what, SyntaxNode node) 
            => Abort("Not Supported: " + what, node);


         public override void DefaultVisit(SyntaxNode node) {
            base.DefaultVisit(node);

            Emit($"/*{node.GetType().Name}*/", node, TokenFlags.Trivia);

            var childs = node.ChildNodesAndTokens();
            foreach (var child in childs) {
               if (child.IsToken) {
                  Emit(child.AsToken().Text, node);
               } else {
                  Visit(child.AsNode());
               }
            }
         }

         public override void VisitMethodDeclaration(MethodDeclarationSyntax node) {
            var semanticModel = context.SemanticModelCache.Get(node.SyntaxTree);
            var method = (IMethodSymbol)semanticModel.GetDeclaredSymbol(node);
            var containingType = node.GetContainingTypeDeclaration();

            QueueAndEmitTypeIdentifier(node.ReturnType);

            var mangledFunctionName = MangleFullName(node);
            Emit(mangledFunctionName, node);

            var selfType = method.IsStatic ? null : containingType;
            VisitParameterListInternal(selfType, node.ParameterList);

            if (node.ExpressionBody != null) {
               Emit("{", node.ExpressionBody);
               Emit("return", node.ExpressionBody);
               Visit(node.ExpressionBody.Expression);
               Emit(";", node.ExpressionBody);
               Emit("}", node.ExpressionBody);
            } else {
               Visit(node.Body);
            }
         }

         public override void VisitParameterList(ParameterListSyntax node) {
            AbortNotSupported("??", node);
         }

         public void VisitParameterListInternal(TypeDeclarationSyntax selfTypeOrNull, ParameterListSyntax node) {
            Emit("(", node);

            bool firstParameter = true;

            if (selfTypeOrNull != null) {
               EmitTypeDeclarationSyntaxMangledIdentifier(selfTypeOrNull, node);
               Emit("self", node);
               firstParameter = false;
            }

            var nodeParameters = node.Parameters;
            for (var i = 0; i < nodeParameters.Count; i++) {
               if (!firstParameter) Emit(",", node);
               VisitParameter(nodeParameters[i]);
               firstParameter = false;
            }

            Emit(")", node);
         }

         public override void VisitParameter(ParameterSyntax node) {
            QueueAndEmitTypeIdentifier(node.Type);
            Emit(node.Identifier.Text, node);

            if (node.AttributeLists.Count != 0) Abort("Attribute List", node);
            if (node.Default != null) Abort("Default", node);
            if (node.Modifiers.Count != 0) Abort("Modifier", node);
         }

         public override void VisitVariableDeclaration(VariableDeclarationSyntax node) {
            QueueAndEmitTypeIdentifier(node.Type);

            var variableDeclarators = node.Variables;
            for (var i = 0 ; i < variableDeclarators.Count; i++) {
               if (i != 0) Emit(",", node);
               Visit(variableDeclarators[i]);
            }
         }

         /// Note: this doesn't cover `default` itself. <seealso cref="VisitLiteralExpression"/>
         public override void VisitDefaultExpression(DefaultExpressionSyntax node) {
            Emit("{}", node);
         }

         /// <seealso cref="VisitDefaultExpression"/> for `default(..)`
         public override void VisitLiteralExpression(LiteralExpressionSyntax node) {
            if (node.Token.IsKind(SyntaxKind.DefaultKeyword)) {
               Emit("{}", node);
            } else {
               Emit(node.Token.Text, node);
            }
         }

         public override void VisitInvocationExpression(InvocationExpressionSyntax node) {
            var (methodNode, invocationTarget) =
               node.Expression is MemberAccessExpressionSyntax mae
                  ? ((SyntaxNode)mae.Name, mae.Expression)
                  : (node.Expression, null);

            var invocationSemanticModel = context.SemanticModelCache.Get(node.SyntaxTree);
            var methodDeclaration = methodNode.GetDeclaringSyntax<MethodDeclarationSyntax>(invocationSemanticModel);
            
            var methodDeclarationSemanticModel = context.SemanticModelCache.Get(methodDeclaration.SyntaxTree);
            var method = methodDeclarationSemanticModel.GetDeclaredSymbol(methodDeclaration);

            QueueAndEmitMethodIdentifier(methodDeclaration, methodNode);
            VisitArgumentListInternal(method, invocationTarget, node.ArgumentList);
         }

         public void VisitArgumentListInternal(IMethodSymbol method, ExpressionSyntax invocationTarget, ArgumentListSyntax node) {
            Emit("(", node);

            bool firstArgument = true;

            if (!method.IsStatic || invocationTarget != null) {
               firstArgument = false;

               if (invocationTarget != null) {
                  Visit(invocationTarget);
               } else {
                  Emit("self", node);
               }
            }

            var nodeArguments = node.Arguments;
            for (var i = 0; i < nodeArguments.Count; i++) {
               if (!firstArgument) Emit(",", node);
               VisitArgument(nodeArguments[i]);
               firstArgument = false;
            }

            Emit(")", node);
         }

         private void QueueAndEmitMethodIdentifier(MethodDeclarationSyntax methodDeclaration, SyntaxNode methodNode) {
            Emit(MangleFullName(methodDeclaration), methodNode);

            var containingType = methodDeclaration.GetContainingTypeDeclaration();
            context.QueuedMethods.Add(new MethodTranspilationJob {
               Method = methodDeclaration,
            });
         }

         private void QueueAndEmitTypeIdentifier(TypeSyntax node) {
            var semanticModel = context.SemanticModelCache.Get(node.SyntaxTree);
            var declarationSyntax = node.GetTypeDeclaringSyntaxOrNull(semanticModel);
            var symbolInfo = semanticModel.GetSymbolInfo(node);

            if (declarationSyntax != null) {
               var mangledTypeName = MangleFullName(declarationSyntax);
               Emit(mangledTypeName, node);
            } else {
               Debugger.Break();
            }
         }

         private void EmitTypeDeclarationSyntaxMangledIdentifier(TypeDeclarationSyntax declarationSyntax, SyntaxNode tag) {
            var mangledTypeName = MangleFullName(declarationSyntax);
            Emit(mangledTypeName, tag);
         }

         private const string MANGLE_NAMESPACE_DELIMITER = "_";
         private const string MANGLE_CLASS_DELIMITER = "___";
         private const string MANGLE_METHOD_DELIMITER = "69";

         // TODO: This is implemented O(N^2). Can be O(N). Consider memoizing.
         private string MangleFullName(MemberDeclarationSyntax mds) {
            if (mds is NamespaceDeclarationSyntax ns) {
               return MangleNamespaceName(ns.Name);
            }

            var name =
               mds is MethodDeclarationSyntax method ? method.Identifier.Text :
               mds is TypeDeclarationSyntax type ? type.Identifier.Text :
               throw Abort("Unhandled Node Type", mds);

            if (mds.Parent is MemberDeclarationSyntax parent) {
               var delimiter =
                  parent is NamespaceDeclarationSyntax ? MANGLE_NAMESPACE_DELIMITER :
                  parent is TypeDeclarationSyntax ? MANGLE_CLASS_DELIMITER :
                  parent is MethodDeclarationSyntax ? MANGLE_METHOD_DELIMITER :
                  throw Abort("Unhandled parent type", parent);

               return MangleFullName(parent) + delimiter + name;
            } else {
               return name;
            }
         }

         private string MangleFullName(ISymbol symbol) {
            if (symbol is INamespaceSymbol ns) {
               return MangleNamespaceName(ns);
            }

            var name =
               symbol is ITypeSymbol type ? type.Name :
               symbol is IMethodSymbol method ? method.Name :
               throw new NotImplementedException("Symbol: " + symbol.GetType().Name + " " + symbol);

            if (symbol.ContainingSymbol is ISymbol parent) {
               var delimiter =
                  parent is INamespaceSymbol ? MANGLE_NAMESPACE_DELIMITER :
                  parent is ITypeSymbol ? MANGLE_CLASS_DELIMITER :
                  parent is IMethodSymbol ? MANGLE_METHOD_DELIMITER :
                  throw new NotImplementedException("Symbol: " + parent.GetType().Name + " " + parent);

               return MangleFullName(parent) + delimiter + name;
            } else {
               return name;
            }
         }

         private string MangleNamespaceName(NameSyntax node) {
            if (node is IdentifierNameSyntax ins) {
               return ins.Identifier.Text;
            } else if (node is QualifiedNameSyntax qns) {
               return MangleNamespaceName(qns.Left) + MANGLE_NAMESPACE_DELIMITER + qns.Right.Identifier.Text;
            } else {
               throw Abort("Unhandled name syntax type", node);
            }
         }

         private string MangleNamespaceName(INamespaceSymbol ns) {
            var parent = ns.ContainingNamespace;
            return parent != null
               ? MangleNamespaceName(parent) + MANGLE_NAMESPACE_DELIMITER + ns.Name
               : ns.Name;
         }
      }
   }

   public enum TranspilationMode { 
      Type,
      Method,
   }

   public class TranspilationContext {
      public Dictionary<string, MethodTranspilation> Methods;
      public Dictionary<string, StructTranspilation> Structs;
      public Dictionary<string, ConstantBufferTranspilation> ConstantBuffers;
   }

   public class MethodTranspilation { }

   public class StructTranspilation { }

   public class ConstantBufferTranspilation { }
}

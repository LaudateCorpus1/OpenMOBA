using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Text;
using Dargon.Commons;
using Dargon.Commons.Cli;
using Dargon.Commons.Collections;
using Dargon.Luna.Lang;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Dargon.Luna.Transpiler.Deoop {
   public class ShaderTranspiler {
      private readonly SemanticModelCache semanticModelCache;
      private readonly KnownTypes knownTypes;

      public ShaderTranspiler(SemanticModelCache semanticModelCache, KnownTypes knownTypes) {
         this.semanticModelCache = semanticModelCache;
         this.knownTypes = knownTypes;
      }

      public void Transpile(IMethodSymbol method) {
         var context = new TranspilationContext();
         context.SemanticModelCache = semanticModelCache;
         context.KnownTypes = knownTypes;
         context.QueuedMethods.Add(new MethodTranspilationJob {
            Method = method,
         });

         var visitor = new TranspilationVisitor(context);
         for (var i = 0; i < context.QueuedMethods.Count; i++) {
            var target = context.QueuedMethods[i];

            Console.WriteLine($"== TRANSPILE {target.Method} ==");
            visitor.Transpile(target);
            Console.WriteLine();
            Console.WriteLine();
         }
      }

      public class TranspilationContext {
         public SemanticModelCache SemanticModelCache;
         public KnownTypes KnownTypes;

         public AddOnlyOrderedHashSet<MethodTranspilationJob> QueuedMethods { get; } = new AddOnlyOrderedHashSet<MethodTranspilationJob>();
         public AddOnlyOrderedHashSet<TypeTranspilationJob> QueuedTypes { get; } = new AddOnlyOrderedHashSet<TypeTranspilationJob>();
      }

      public struct MethodTranspilationJob : IEquatable<MethodTranspilationJob> {
         public IMethodSymbol Method;

         #region autogenerated equality
         public bool Equals(MethodTranspilationJob other) {
            return Equals(Method, other.Method);
         }

         public override bool Equals(object obj) {
            return obj is MethodTranspilationJob other && Equals(other);
         }

         public override int GetHashCode() {
            return (Method != null ? Method.GetHashCode() : 0);
         }

         public static bool operator ==(MethodTranspilationJob left, MethodTranspilationJob right) {
            return left.Equals(right);
         }

         public static bool operator !=(MethodTranspilationJob left, MethodTranspilationJob right) {
            return !left.Equals(right);
         }
         #endregion
      }

      public struct TypeTranspilationJob : IEquatable<TypeTranspilationJob> {
         public ITypeSymbol TypeSymbol;

         #region autogenerated equality
         public bool Equals(TypeTranspilationJob other) {
            return Equals(TypeSymbol, other.TypeSymbol);
         }

         public override bool Equals(object obj) {
            return obj is TypeTranspilationJob other && Equals(other);
         }

         public override int GetHashCode() {
            return (TypeSymbol != null ? TypeSymbol.GetHashCode() : 0);
         }

         public static bool operator ==(TypeTranspilationJob left, TypeTranspilationJob right) {
            return left.Equals(right);
         }

         public static bool operator !=(TypeTranspilationJob left, TypeTranspilationJob right) {
            return !left.Equals(right);
         }
         #endregion

         public static TypeTranspilationJob Create(ITypeSymbol typeSymbol) {
            return new TypeTranspilationJob { 
               TypeSymbol = typeSymbol,
            };
         }
      }

      public class TranspilationVisitor : CSharpSyntaxVisitor {
         private readonly TranspilationContext context;

         public TranspilationVisitor(TranspilationContext context) {
            this.context = context;
         }

         private TranspilationMode mode;

         public void Transpile(MethodTranspilationJob job) {
            mode = TranspilationMode.Method;

            var declarations = job.Method.DeclaringSyntaxReferences;
            Assert.Equals(1, declarations.Length);

            VisitBaseMethodDeclarationInternal((BaseMethodDeclarationSyntax)declarations[0].GetSyntax());
         }

         [Flags]
         public enum TokenFlags {
            Trivia = 1 << 0,
            Whitespace = 1 << 1,
         }

         public void Emit(string token, SyntaxNode tag, TokenFlags flags = 0) {
            var (fg, bg) = (flags & TokenFlags.Trivia) != 0 ? (ConsoleColor.DarkGray, null) :
               (flags & TokenFlags.Whitespace) != 0 ? (ConsoleColor.Gray, null) :
               ((ConsoleColor?)ConsoleColor.White, (ConsoleColor?)null);

            using (new ConsoleColorSwitch().To(fg, bg)) {
               Console.Write(token + " ");
            }
         }

         public void EmitSpace(SyntaxNode tag) {
            Emit("", tag, TokenFlags.Whitespace);
         }

         private Exception Abort(string reason, SyntaxNode node) {
            Console.WriteLine("=== " + reason + " ===");
            throw Diag.DumpExpressionAndSyntaxTreeThenReturnThrow(node);
         }

         private Exception AbortNotSupported(string what, SyntaxNode node) 
            => Abort("Not Supported: " + what, node);


         public override void DefaultVisit(SyntaxNode node) {
            base.DefaultVisit(node);

            Emit($"/*{node.GetType().Name}*/", node, TokenFlags.Trivia);

            var childs = node.ChildNodesAndTokens();
            VisitNodesAndEmitTokens(childs, node, 0, childs.Count);
         }

         private void VisitNodesAndEmitTokens(ChildSyntaxList childs, SyntaxNode tokenTag, int startIndexInclusive, int endIndexExclusive) {
            for (var index = startIndexInclusive; index < endIndexExclusive; index++) {
               var child = childs[index];
               if (child.IsToken) {
                  Emit(child.AsToken().Text, tokenTag);
               } else {
                  Visit(child.AsNode());
               }
            }
         }

         public override void VisitMethodDeclaration(MethodDeclarationSyntax node) {
            AbortNotSupported("Reached Method Declaration?", node);
         }

         public void VisitBaseMethodDeclarationInternal(BaseMethodDeclarationSyntax node) {
            var semanticModel = context.SemanticModelCache.Get(node.SyntaxTree);
            var method = (IMethodSymbol)semanticModel.GetDeclaredSymbol(node);
            var containingType = method.ReceiverType;
            QueueType(containingType);

            // emit return type
            ITypeSymbol selfTypeOrNull;
            TypeDeclarationSyntax structCtorTypeOrNull;

            if (node is MethodDeclarationSyntax mds) {
               selfTypeOrNull = method.IsStatic ? null : method.ReceiverType;
               structCtorTypeOrNull = null;

               QueueAndEmitTypeIdentifier(mds.ReturnType);
            } else if (node is ConstructorDeclarationSyntax ctor) {
               selfTypeOrNull = null;
               structCtorTypeOrNull = (TypeDeclarationSyntax)ctor.Parent;

               EmitTypeDeclarationSyntaxMangledIdentifier(structCtorTypeOrNull, ctor);
            } else {
               throw AbortNotSupported("Unknown method-like: ", node);
            }

            var mangledFunctionName = MangleFullName(node);
            Emit(mangledFunctionName, node);

            VisitParameterListInternal(selfTypeOrNull, node.ParameterList);

            if (node.ExpressionBody != null) {
               Emit("{", node.ExpressionBody);
               Emit("return", node.ExpressionBody);
               Visit(node.ExpressionBody.Expression);
               Emit(";", node.ExpressionBody);
               Emit("}", node.ExpressionBody);
            } else {
               VisitBlockInternal(node.Body, structCtorTypeOrNull, node);
            }
         }

         public override void VisitParameterList(ParameterListSyntax node) {
            AbortNotSupported("??", node);
         }

         public void VisitParameterListInternal(ITypeSymbol selfTypeOrNull, ParameterListSyntax node) {
            Emit("(", node);

            bool firstParameter = true;

            if (selfTypeOrNull != null) {
               Emit("inout", node);
               Emit(MangleFullName(selfTypeOrNull), node);
               Emit(SELF_TOKEN, node);
               firstParameter = false;
            }

            var nodeParameters = node.Parameters;
            for (var i = 0; i < nodeParameters.Count; i++) {
               if (!firstParameter) Emit(",", node);
               VisitParameter(nodeParameters[i]);
               firstParameter = false;
            }

            Emit(")", node);
         }

         public override void VisitParameter(ParameterSyntax node) {
            QueueAndEmitTypeIdentifier(node.Type);
            Emit(node.Identifier.Text, node);

            if (node.AttributeLists.Count != 0) Abort("Attribute List", node);
            if (node.Default != null) Abort("Default", node);
            if (node.Modifiers.Count != 0) Abort("Modifier", node);
         }

         public override void VisitBlock(BlockSyntax node) {
            VisitBlockInternal(node, null, null);
         }

         private void VisitBlockInternal(BlockSyntax node, TypeDeclarationSyntax structCtorSelfOpt, BaseMethodDeclarationSyntax structCtorAutogenCtorTagOpt) {
            var childs = node.ChildNodesAndTokens();
            Assert.Equals("{", childs[0].AsToken().Text);
            Assert.Equals("}", childs[childs.Count - 1].AsToken().Text);

            Emit("{", node);

            if (structCtorSelfOpt != null) {
               EmitTypeDeclarationSyntaxMangledIdentifier(structCtorSelfOpt, structCtorAutogenCtorTagOpt);
               Emit(SELF_TOKEN, structCtorAutogenCtorTagOpt);
               Emit("=", structCtorAutogenCtorTagOpt);
               Emit("{}", structCtorAutogenCtorTagOpt);
               Emit(";", structCtorAutogenCtorTagOpt);
            }

            VisitNodesAndEmitTokens(childs, node, 1, childs.Count - 1);

            if (structCtorSelfOpt != null) {
               Emit("return", structCtorAutogenCtorTagOpt);
               Emit(SELF_TOKEN, structCtorAutogenCtorTagOpt);
               Emit(";", structCtorAutogenCtorTagOpt);
            }

            Emit("}", node);
         }

         public override void VisitVariableDeclaration(VariableDeclarationSyntax node) {
            QueueAndEmitTypeIdentifier(node.Type);

            var variableDeclarators = node.Variables;
            for (var i = 0 ; i < variableDeclarators.Count; i++) {
               if (i != 0) Emit(",", node);
               Visit(variableDeclarators[i]);
            }
         }

         /// Note: this doesn't cover `default` itself. <seealso cref="VisitLiteralExpression"/>
         public override void VisitDefaultExpression(DefaultExpressionSyntax node) {
            Emit("{}", node);
         }

         /// <seealso cref="VisitDefaultExpression"/> for `default(..)`
         public override void VisitLiteralExpression(LiteralExpressionSyntax node) {
            if (node.Token.IsKind(SyntaxKind.DefaultKeyword)) {
               Emit("{}", node);
            } else {
               Emit(node.Token.Text, node);
            }
         }

         public override void VisitInvocationExpression(InvocationExpressionSyntax node) {
            var (methodIdentifierNode, invocationTarget) =
               node.Expression is MemberAccessExpressionSyntax mae
                  ? ((SyntaxNode)mae.Name, mae.Expression)
                  : (node.Expression, null);

            var invocationSemanticModel = context.SemanticModelCache.Get(node.SyntaxTree);
            var methodSymbolInfo = invocationSemanticModel.GetSymbolInfo(methodIdentifierNode);
            var method = (IMethodSymbol)methodSymbolInfo.Symbol;
            Assert.IsNotNull(method);

            QueueAndEmitMethodIdentifier(method, methodIdentifierNode);
            VisitArgumentListInternal(method, invocationTarget, node.ArgumentList);

            if (invocationTarget != null) {
               var invocationTargetTypeInfo = invocationSemanticModel.GetTypeInfo(invocationTarget);
               var invocationTargetType = invocationTargetTypeInfo.Type;
               QueueType(invocationTargetType);
            }
         }

         public void VisitArgumentListInternal(IMethodSymbol method, ExpressionSyntax invocationTarget, ArgumentListSyntax node) {
            Emit("(", node);

            bool firstArgument = true;

            if ((!method.IsStatic && method.MethodKind != MethodKind.Constructor) || (invocationTarget != null)) {
               firstArgument = false;

               if (invocationTarget != null) {
                  Visit(invocationTarget);
               } else {
                  Emit(SELF_TOKEN, node);
               }
            }

            var nodeArguments = node.Arguments;
            for (var i = 0; i < nodeArguments.Count; i++) {
               if (!firstArgument) Emit(",", node);
               VisitArgument(nodeArguments[i]);
               firstArgument = false;
            }

            Emit(")", node);
         }

         public override void VisitObjectCreationExpression(ObjectCreationExpressionSyntax node) {
            var semanticModel = context.SemanticModelCache.Get(node.SyntaxTree);
            var ctor = (IMethodSymbol)semanticModel.GetSymbolInfo(node).Symbol;

            QueueType(node.Type);

            // Note: an implicit ctor still has a method symbol w/ no declaration.
            if (ctor.Parameters.Length == 0 && ctor.DeclaringSyntaxReferences.Length == 0) {
               // TODO: This is broken if a parameterless ctor's class has field initializers!
               Emit("{}", node);
            } else {
               QueueAndEmitMethodIdentifier(ctor, node);
               VisitArgumentListInternal(ctor, null, node.ArgumentList);
            }
         }

         public override void VisitThisExpression(ThisExpressionSyntax node) {
            Emit(SELF_TOKEN, node);
         }

         public override void VisitIdentifierName(IdentifierNameSyntax node) {
            var isImplicitThisCandidate =
               !(node.Parent is MemberAccessExpressionSyntax mae) || mae.Expression == node;

            if (isImplicitThisCandidate) {
               var semanticModel = context.SemanticModelCache.Get(node.SyntaxTree);
               var symbol = semanticModel.GetSymbolInfo(node).Symbol;
               var declarations = symbol.DeclaringSyntaxReferences;
               Assert.Equals(1, declarations.Length);

               var decl = declarations[0].GetSyntax();

               if ((decl is VariableDeclaratorSyntax declarator &&
                    declarator.Parent is VariableDeclarationSyntax declaration &&
                    declaration.Parent is FieldDeclarationSyntax fieldDeclaration)) {
                  Emit(SELF_TOKEN, node);
                  Emit(".", node);
               }
            }

            Emit(node.Identifier.Text, node);
         }

         public override void VisitMemberAccessExpression(MemberAccessExpressionSyntax node) {
            var semanticModel = context.SemanticModelCache.Get(node.SyntaxTree);
            var targetSymbol = semanticModel.GetSymbolInfo(node.Name).Symbol;
            Assert.IsNotNull(targetSymbol);


            var containingType = targetSymbol.ContainingType;
            if (containingType != null && TryGetConstantBufferAttribute(containingType, out var constantBufferAttribute)) {
               var cbName = constantBufferAttribute.Name ?? containingType.Name;
               Emit(cbName + "_" + node.Name.Identifier, node);
            } else {
               base.VisitMemberAccessExpression(node);
            }
         }

         public bool TryGetConstantBufferAttribute(INamedTypeSymbol nts, out ConstantBufferAttribute res) {
            var attributes = nts.GetAttributes();
            foreach (var attr in attributes) {
               if (!SymbolEqualityComparer.Default.Equals(attr.AttributeClass, context.KnownTypes.ConstantBufferAttributeSymbol)) {
                  continue;
               }

               res = InstantiateAttribute<ConstantBufferAttribute>(attr);
               return true;
            }

            res = null;
            return false;
         }

         public T InstantiateAttribute<T>(AttributeData data) where T : Attribute {
            var ctors = typeof(T).GetConstructors();
            var ctor = ctors.FirstAndOnly();
            var inst = (T)ctor.Invoke(data.ConstructorArguments.Map(a => a.Value));
            foreach (var (key, assignment) in data.NamedArguments) {
               typeof(T).GetProperty(key, BindingFlags.Instance).SetValue(inst, assignment.Value);
            }
            return inst;
         }

         private void QueueAndEmitMethodIdentifier(IMethodSymbol method, SyntaxNode methodNode) {
            Emit(MangleFullName(method), methodNode);

            context.QueuedMethods.Add(new MethodTranspilationJob {
               Method = method,
            });
         }

         private void QueueType(ITypeSymbol type) {
            if (context.KnownTypes.IsFrameworkType(type)) return;
            context.QueuedTypes.Add(TypeTranspilationJob.Create(type));
         }

         private void QueueType(TypeSyntax node)
            => QueueAndEmitTypeIdentifierInternal(node, false);

         private void QueueAndEmitTypeIdentifier(TypeSyntax node)
            => QueueAndEmitTypeIdentifierInternal(node, true);

         private void QueueAndEmitTypeIdentifierInternal(TypeSyntax node, bool emit) {
            var semanticModel = context.SemanticModelCache.Get(node.SyntaxTree);
            var symbol = (ITypeSymbol)semanticModel.GetSymbolInfo(node).Symbol;
            Assert.IsNotNull(symbol);
            
            if (SymbolEqualityComparer.Default.Equals(symbol, context.KnownTypes.FloatSymbol)) {
               if (emit) Emit("float", node);
            } else {
               Assert.IsFalse(context.KnownTypes.IsFrameworkType(symbol));

               var declarationSyntax = node.GetTypeDeclaringSyntax(semanticModel);
               var mangledTypeName = MangleFullName(declarationSyntax);
               if (emit) Emit(mangledTypeName, node);
            }
         }

         private void EmitTypeDeclarationSyntaxMangledIdentifier(TypeDeclarationSyntax declarationSyntax, SyntaxNode tag) {
            var mangledTypeName = MangleFullName(declarationSyntax);
            Emit(mangledTypeName, tag);
         }

         private const string MANGLE_NAMESPACE_DELIMITER = "_";
         private const string MANGLE_CLASS_DELIMITER = "___";
         private const string MANGLE_METHOD_DELIMITER = "69";
         private const string MANGLE_CTOR_PARAM_TYPE_DELIMITER = "420";
         private const string SELF_TOKEN = "self";

         // TODO: This is implemented O(N^2). Can be O(N). Consider memoizing.
         private string MangleFullName(MemberDeclarationSyntax mds) {
            if (mds is NamespaceDeclarationSyntax ns) {
               return MangleNamespaceName(ns.Name);
            }

            var name =
               mds is TypeDeclarationSyntax type ? type.Identifier.Text :
               mds is ConstructorDeclarationSyntax ctor ? MangleConstructorName(ctor) :
               mds is MethodDeclarationSyntax method ? MangleMethodName(method) :
               throw Abort("Unhandled Node Type", mds);

            if (mds.Parent is MemberDeclarationSyntax parent) {
               var delimiter =
                  parent is NamespaceDeclarationSyntax ? MANGLE_NAMESPACE_DELIMITER :
                  parent is TypeDeclarationSyntax ? MANGLE_CLASS_DELIMITER :
                  parent is ConstructorDeclarationSyntax ? MANGLE_METHOD_DELIMITER :
                  parent is MethodDeclarationSyntax ? MANGLE_METHOD_DELIMITER :
                  throw Abort("Unhandled parent type", parent);

               return MangleFullName(parent) + delimiter + name;
            } else {
               return name;
            }
         }

         private string MangleConstructorName(ConstructorDeclarationSyntax ctor) {
            var semanticModel = context.SemanticModelCache.Get(ctor.SyntaxTree);
            var methodSymbol = semanticModel.GetDeclaredSymbol(ctor);
            return MangleMethodName(methodSymbol);
         }

         private string MangleMethodName(MethodDeclarationSyntax method) {
            var semanticModel = context.SemanticModelCache.Get(method.SyntaxTree);
            var methodSymbol = semanticModel.GetDeclaredSymbol(method);
            return MangleMethodName(methodSymbol);
         }

         private string MangleMethodName(IMethodSymbol method) {
            if (method.MethodKind == MethodKind.Constructor) {
               var sb = new StringBuilder();
               
               sb.Append(method.Name);

               foreach (var p in method.Parameters) {
                  sb.Append(MANGLE_CTOR_PARAM_TYPE_DELIMITER);
                  sb.Append(MangleFullName(p.Type));
               }

               return sb.ToString();
            }

            return method.Name;
         }

         private string MangleFullName(ISymbol symbol) {
            if (symbol is INamespaceSymbol ns) {
               return MangleNamespaceName(ns);
            }

            var name =
               symbol is ITypeSymbol type ? type.Name :
               symbol is IMethodSymbol method ? MangleMethodName(method) :
               throw new NotImplementedException("Symbol: " + symbol.GetType().Name + " " + symbol);

            if (symbol.ContainingSymbol is ISymbol parent &&
                !(parent is INamespaceSymbol pns && pns.IsGlobalNamespace)) {
               var delimiter =
                  parent is INamespaceSymbol ? MANGLE_NAMESPACE_DELIMITER :
                  parent is ITypeSymbol ? MANGLE_CLASS_DELIMITER :
                  parent is IMethodSymbol ? MANGLE_METHOD_DELIMITER :
                  throw new NotImplementedException("Symbol: " + parent.GetType().Name + " " + parent);

               return MangleFullName(parent) + delimiter + name;
            } else {
               return name;
            }
         }

         private string MangleNamespaceName(NameSyntax node) {
            if (node is IdentifierNameSyntax ins) {
               return ins.Identifier.Text;
            } else if (node is QualifiedNameSyntax qns) {
               return MangleNamespaceName(qns.Left) + MANGLE_NAMESPACE_DELIMITER + qns.Right.Identifier.Text;
            } else {
               throw Abort("Unhandled name syntax type", node);
            }
         }

         private string MangleNamespaceName(INamespaceSymbol ns) {
            var parent = ns.ContainingNamespace;
            return parent != null && !parent.IsGlobalNamespace
               ? MangleNamespaceName(parent) + MANGLE_NAMESPACE_DELIMITER + ns.Name
               : ns.Name;
         }
      }
   }

   public enum TranspilationMode { 
      Type,
      Method,
   }

   public class TranspilationContext {
      public Dictionary<string, MethodTranspilation> Methods;
      public Dictionary<string, StructTranspilation> Structs;
      public Dictionary<string, ConstantBufferTranspilation> ConstantBuffers;
   }

   public class MethodTranspilation { }

   public class StructTranspilation { }

   public class ConstantBufferTranspilation { }
}
